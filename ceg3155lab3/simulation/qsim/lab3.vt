// Copyright (C) 1991-2013 Altera Corporation
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, Altera MegaCore Function License 
// Agreement, or other applicable license agreement, including, 
// without limitation, that your use is for the sole purpose of 
// programming logic devices manufactured by Altera and sold by 
// Altera or its authorized distributors.  Please refer to the 
// applicable agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench with test vectors .The test vectors  
// are exported from a vector file in the Quartus Waveform Editor and apply to  
// the top level entity of the current Quartus project .The user can use this   
// testbench to simulate his design using a third-party simulation tool .       
// *****************************************************************************
// Generated on "11/15/2021 11:28:59"
                                                                        
// Verilog Self-Checking Test Bench (with test vectors) for design :    lab3
// 
// Simulation tool : 3rd Party
// 

`timescale 1 ps/ 1 ps
module lab3_vlg_sample_tst(
	GClock,
	GReset_raw,
	msc,
	ssc,
	sscs_raw,
	sampler_tx
);
input  GClock;
input  GReset_raw;
input [3:0] msc;
input [3:0] ssc;
input  sscs_raw;
output sampler_tx;

reg sample;
time current_time;
always @(GClock or GReset_raw or msc or ssc or sscs_raw)
                                                                                
begin                                                 
 if ($realtime > 0)                                   
 begin                                                
	if ($realtime == 0 || $realtime != current_time)  
	begin									          
		if (sample === 1'bx)                          
			sample = 0;                               
		else                                          
			sample = ~sample;                         
	end										          
	current_time = $realtime;					      
 end                                                  
end                                                   

assign sampler_tx = sample;
endmodule

module lab3_vlg_check_tst (
	c_reset,
	ccc,
	main_t,
	mstl,
	side_t,
	sstl,
	states,
	states2,
	stt,
	stt1,
	stt2,
	timer_reset,
	sampler_rx
);
input  c_reset;
input  ccc;
input  main_t;
input [2:0] mstl;
input  side_t;
input [2:0] sstl;
input [3:0] states;
input [3:0] states2;
input [3:0] stt;
input [3:0] stt1;
input [3:0] stt2;
input  timer_reset;
input sampler_rx;

reg  c_reset_expected;
reg  ccc_expected;
reg  main_t_expected;
reg [2:0] mstl_expected;
reg  side_t_expected;
reg [2:0] sstl_expected;
reg [3:0] states_expected;
reg [3:0] states2_expected;
reg [3:0] stt_expected;
reg [3:0] stt1_expected;
reg [3:0] stt2_expected;
reg  timer_reset_expected;

reg  c_reset_prev;
reg  ccc_prev;
reg  main_t_prev;
reg [2:0] mstl_prev;
reg  side_t_prev;
reg [2:0] sstl_prev;
reg [3:0] states_prev;
reg [3:0] states2_prev;
reg [3:0] stt_prev;
reg [3:0] stt1_prev;
reg [3:0] stt2_prev;
reg  timer_reset_prev;

reg  c_reset_expected_prev;
reg  ccc_expected_prev;
reg  main_t_expected_prev;
reg [2:0] mstl_expected_prev;
reg  side_t_expected_prev;
reg [2:0] sstl_expected_prev;
reg [3:0] states_expected_prev;
reg [3:0] states2_expected_prev;
reg [3:0] stt_expected_prev;
reg [3:0] stt1_expected_prev;
reg [3:0] stt2_expected_prev;
reg  timer_reset_expected_prev;

reg  last_c_reset_exp;
reg  last_ccc_exp;
reg  last_main_t_exp;
reg [2:0] last_mstl_exp;
reg  last_side_t_exp;
reg [2:0] last_sstl_exp;
reg [3:0] last_states_exp;
reg [3:0] last_states2_exp;
reg [3:0] last_stt_exp;
reg [3:0] last_stt1_exp;
reg [3:0] last_stt2_exp;
reg  last_timer_reset_exp;

reg trigger;

integer i;
integer nummismatches;

reg [1:12] on_first_change ;


initial
begin
trigger = 0;
i = 0;
nummismatches = 0;
on_first_change = 12'b1;
end

// update real /o prevs

always @(trigger)
begin
	c_reset_prev = c_reset;
	ccc_prev = ccc;
	main_t_prev = main_t;
	mstl_prev = mstl;
	side_t_prev = side_t;
	sstl_prev = sstl;
	states_prev = states;
	states2_prev = states2;
	stt_prev = stt;
	stt1_prev = stt1;
	stt2_prev = stt2;
	timer_reset_prev = timer_reset;
end

// update expected /o prevs

always @(trigger)
begin
	c_reset_expected_prev = c_reset_expected;
	ccc_expected_prev = ccc_expected;
	main_t_expected_prev = main_t_expected;
	mstl_expected_prev = mstl_expected;
	side_t_expected_prev = side_t_expected;
	sstl_expected_prev = sstl_expected;
	states_expected_prev = states_expected;
	states2_expected_prev = states2_expected;
	stt_expected_prev = stt_expected;
	stt1_expected_prev = stt1_expected;
	stt2_expected_prev = stt2_expected;
	timer_reset_expected_prev = timer_reset_expected;
end


// expected mstl[ 2 ]
initial
begin
	mstl_expected[2] = 1'bX;
	mstl_expected[2] = #9000 1'b0;
end 
// expected mstl[ 1 ]
initial
begin
	mstl_expected[1] = 1'bX;
	mstl_expected[1] = #9000 1'b0;
end 
// expected mstl[ 0 ]
initial
begin
	mstl_expected[0] = 1'bX;
	mstl_expected[0] = #9000 1'b0;
end 
// expected sstl[ 2 ]
initial
begin
	sstl_expected[2] = 1'bX;
	sstl_expected[2] = #9000 1'b0;
end 
// expected sstl[ 1 ]
initial
begin
	sstl_expected[1] = 1'bX;
	sstl_expected[1] = #9000 1'b0;
end 
// expected sstl[ 0 ]
initial
begin
	sstl_expected[0] = 1'bX;
	sstl_expected[0] = #9000 1'b0;
end 
// expected states[ 3 ]
initial
begin
	states_expected[3] = 1'bX;
	states_expected[3] = #1999000 1'b0;
end 
// expected states[ 2 ]
initial
begin
	states_expected[2] = 1'bX;
	states_expected[2] = #1999000 1'b0;
end 
// expected states[ 1 ]
initial
begin
	states_expected[1] = 1'bX;
	states_expected[1] = #1999000 1'b0;
end 
// expected states[ 0 ]
initial
begin
	states_expected[0] = 1'bX;
	states_expected[0] = #1999000 1'b0;
end 
// expected states2[ 3 ]
initial
begin
	states2_expected[3] = 1'bX;
	states2_expected[3] = #1999000 1'b0;
end 
// expected states2[ 2 ]
initial
begin
	states2_expected[2] = 1'bX;
	states2_expected[2] = #1999000 1'b0;
end 
// expected states2[ 1 ]
initial
begin
	states2_expected[1] = 1'bX;
	states2_expected[1] = #1999000 1'b0;
end 
// expected states2[ 0 ]
initial
begin
	states2_expected[0] = 1'bX;
	states2_expected[0] = #1999000 1'b0;
end 

// expected ccc
initial
begin
	ccc_expected = 1'bX;
	ccc_expected = #1999000 1'b0;
end 

// expected main_t
initial
begin
	main_t_expected = 1'bX;
	main_t_expected = #1999000 1'b0;
end 

// expected side_t
initial
begin
	side_t_expected = 1'bX;
	side_t_expected = #1999000 1'b0;
end 

// expected c_reset
initial
begin
	c_reset_expected = 1'bX;
	c_reset_expected = #1999000 1'b0;
end 

// expected timer_reset
initial
begin
	timer_reset_expected = 1'bX;
	timer_reset_expected = #1999000 1'b0;
end 
// expected stt1[ 3 ]
initial
begin
	stt1_expected[3] = 1'bX;
	stt1_expected[3] = #1999000 1'b0;
end 
// expected stt1[ 2 ]
initial
begin
	stt1_expected[2] = 1'bX;
	stt1_expected[2] = #1999000 1'b0;
end 
// expected stt1[ 1 ]
initial
begin
	stt1_expected[1] = 1'bX;
	stt1_expected[1] = #1999000 1'b0;
end 
// expected stt1[ 0 ]
initial
begin
	stt1_expected[0] = 1'bX;
	stt1_expected[0] = #1999000 1'b0;
end 
// expected stt[ 3 ]
initial
begin
	stt_expected[3] = 1'bX;
	stt_expected[3] = #1999000 1'b0;
end 
// expected stt[ 2 ]
initial
begin
	stt_expected[2] = 1'bX;
	stt_expected[2] = #1999000 1'b0;
end 
// expected stt[ 1 ]
initial
begin
	stt_expected[1] = 1'bX;
	stt_expected[1] = #1999000 1'b0;
end 
// expected stt[ 0 ]
initial
begin
	stt_expected[0] = 1'bX;
	stt_expected[0] = #1999000 1'b0;
end 
// expected stt2[ 3 ]
initial
begin
	stt2_expected[3] = 1'bX;
	stt2_expected[3] = #1999000 1'b0;
end 
// expected stt2[ 2 ]
initial
begin
	stt2_expected[2] = 1'bX;
	stt2_expected[2] = #1999000 1'b0;
end 
// expected stt2[ 1 ]
initial
begin
	stt2_expected[1] = 1'bX;
	stt2_expected[1] = #1999000 1'b0;
end 
// expected stt2[ 0 ]
initial
begin
	stt2_expected[0] = 1'bX;
	stt2_expected[0] = #1999000 1'b0;
end 
// generate trigger
always @(c_reset_expected or c_reset or ccc_expected or ccc or main_t_expected or main_t or mstl_expected or mstl or side_t_expected or side_t or sstl_expected or sstl or states_expected or states or states2_expected or states2 or stt_expected or stt or stt1_expected or stt1 or stt2_expected or stt2 or timer_reset_expected or timer_reset)
begin
	trigger <= ~trigger;
end

always @(posedge sampler_rx or negedge sampler_rx)
begin
`ifdef debug_tbench
	$display("Scanning pattern %d @time = %t",i,$realtime );
	i = i + 1;
	$display("| expected c_reset = %b | expected ccc = %b | expected main_t = %b | expected mstl = %b | expected side_t = %b | expected sstl = %b | expected states = %b | expected states2 = %b | expected stt = %b | expected stt1 = %b | expected stt2 = %b | expected timer_reset = %b | ",c_reset_expected_prev,ccc_expected_prev,main_t_expected_prev,mstl_expected_prev,side_t_expected_prev,sstl_expected_prev,states_expected_prev,states2_expected_prev,stt_expected_prev,stt1_expected_prev,stt2_expected_prev,timer_reset_expected_prev);
	$display("| real c_reset = %b | real ccc = %b | real main_t = %b | real mstl = %b | real side_t = %b | real sstl = %b | real states = %b | real states2 = %b | real stt = %b | real stt1 = %b | real stt2 = %b | real timer_reset = %b | ",c_reset_prev,ccc_prev,main_t_prev,mstl_prev,side_t_prev,sstl_prev,states_prev,states2_prev,stt_prev,stt1_prev,stt2_prev,timer_reset_prev);
`endif
	if (
		( c_reset_expected_prev !== 1'bx ) && ( c_reset_prev !== c_reset_expected_prev )
		&& ((c_reset_expected_prev !== last_c_reset_exp) ||
			on_first_change[1])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port c_reset :: @time = %t",  $realtime);
		$display ("     Expected value = %b", c_reset_expected_prev);
		$display ("     Real value = %b", c_reset_prev);
		nummismatches = nummismatches + 1;
		on_first_change[1] = 1'b0;
		last_c_reset_exp = c_reset_expected_prev;
	end
	if (
		( ccc_expected_prev !== 1'bx ) && ( ccc_prev !== ccc_expected_prev )
		&& ((ccc_expected_prev !== last_ccc_exp) ||
			on_first_change[2])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port ccc :: @time = %t",  $realtime);
		$display ("     Expected value = %b", ccc_expected_prev);
		$display ("     Real value = %b", ccc_prev);
		nummismatches = nummismatches + 1;
		on_first_change[2] = 1'b0;
		last_ccc_exp = ccc_expected_prev;
	end
	if (
		( main_t_expected_prev !== 1'bx ) && ( main_t_prev !== main_t_expected_prev )
		&& ((main_t_expected_prev !== last_main_t_exp) ||
			on_first_change[3])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port main_t :: @time = %t",  $realtime);
		$display ("     Expected value = %b", main_t_expected_prev);
		$display ("     Real value = %b", main_t_prev);
		nummismatches = nummismatches + 1;
		on_first_change[3] = 1'b0;
		last_main_t_exp = main_t_expected_prev;
	end
	if (
		( mstl_expected_prev[0] !== 1'bx ) && ( mstl_prev[0] !== mstl_expected_prev[0] )
		&& ((mstl_expected_prev[0] !== last_mstl_exp[0]) ||
			on_first_change[4])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port mstl[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", mstl_expected_prev);
		$display ("     Real value = %b", mstl_prev);
		nummismatches = nummismatches + 1;
		on_first_change[4] = 1'b0;
		last_mstl_exp[0] = mstl_expected_prev[0];
	end
	if (
		( mstl_expected_prev[1] !== 1'bx ) && ( mstl_prev[1] !== mstl_expected_prev[1] )
		&& ((mstl_expected_prev[1] !== last_mstl_exp[1]) ||
			on_first_change[4])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port mstl[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", mstl_expected_prev);
		$display ("     Real value = %b", mstl_prev);
		nummismatches = nummismatches + 1;
		on_first_change[4] = 1'b0;
		last_mstl_exp[1] = mstl_expected_prev[1];
	end
	if (
		( mstl_expected_prev[2] !== 1'bx ) && ( mstl_prev[2] !== mstl_expected_prev[2] )
		&& ((mstl_expected_prev[2] !== last_mstl_exp[2]) ||
			on_first_change[4])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port mstl[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", mstl_expected_prev);
		$display ("     Real value = %b", mstl_prev);
		nummismatches = nummismatches + 1;
		on_first_change[4] = 1'b0;
		last_mstl_exp[2] = mstl_expected_prev[2];
	end
	if (
		( side_t_expected_prev !== 1'bx ) && ( side_t_prev !== side_t_expected_prev )
		&& ((side_t_expected_prev !== last_side_t_exp) ||
			on_first_change[5])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port side_t :: @time = %t",  $realtime);
		$display ("     Expected value = %b", side_t_expected_prev);
		$display ("     Real value = %b", side_t_prev);
		nummismatches = nummismatches + 1;
		on_first_change[5] = 1'b0;
		last_side_t_exp = side_t_expected_prev;
	end
	if (
		( sstl_expected_prev[0] !== 1'bx ) && ( sstl_prev[0] !== sstl_expected_prev[0] )
		&& ((sstl_expected_prev[0] !== last_sstl_exp[0]) ||
			on_first_change[6])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sstl[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sstl_expected_prev);
		$display ("     Real value = %b", sstl_prev);
		nummismatches = nummismatches + 1;
		on_first_change[6] = 1'b0;
		last_sstl_exp[0] = sstl_expected_prev[0];
	end
	if (
		( sstl_expected_prev[1] !== 1'bx ) && ( sstl_prev[1] !== sstl_expected_prev[1] )
		&& ((sstl_expected_prev[1] !== last_sstl_exp[1]) ||
			on_first_change[6])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sstl[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sstl_expected_prev);
		$display ("     Real value = %b", sstl_prev);
		nummismatches = nummismatches + 1;
		on_first_change[6] = 1'b0;
		last_sstl_exp[1] = sstl_expected_prev[1];
	end
	if (
		( sstl_expected_prev[2] !== 1'bx ) && ( sstl_prev[2] !== sstl_expected_prev[2] )
		&& ((sstl_expected_prev[2] !== last_sstl_exp[2]) ||
			on_first_change[6])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sstl[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sstl_expected_prev);
		$display ("     Real value = %b", sstl_prev);
		nummismatches = nummismatches + 1;
		on_first_change[6] = 1'b0;
		last_sstl_exp[2] = sstl_expected_prev[2];
	end
	if (
		( states_expected_prev[0] !== 1'bx ) && ( states_prev[0] !== states_expected_prev[0] )
		&& ((states_expected_prev[0] !== last_states_exp[0]) ||
			on_first_change[7])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port states[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", states_expected_prev);
		$display ("     Real value = %b", states_prev);
		nummismatches = nummismatches + 1;
		on_first_change[7] = 1'b0;
		last_states_exp[0] = states_expected_prev[0];
	end
	if (
		( states_expected_prev[1] !== 1'bx ) && ( states_prev[1] !== states_expected_prev[1] )
		&& ((states_expected_prev[1] !== last_states_exp[1]) ||
			on_first_change[7])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port states[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", states_expected_prev);
		$display ("     Real value = %b", states_prev);
		nummismatches = nummismatches + 1;
		on_first_change[7] = 1'b0;
		last_states_exp[1] = states_expected_prev[1];
	end
	if (
		( states_expected_prev[2] !== 1'bx ) && ( states_prev[2] !== states_expected_prev[2] )
		&& ((states_expected_prev[2] !== last_states_exp[2]) ||
			on_first_change[7])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port states[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", states_expected_prev);
		$display ("     Real value = %b", states_prev);
		nummismatches = nummismatches + 1;
		on_first_change[7] = 1'b0;
		last_states_exp[2] = states_expected_prev[2];
	end
	if (
		( states_expected_prev[3] !== 1'bx ) && ( states_prev[3] !== states_expected_prev[3] )
		&& ((states_expected_prev[3] !== last_states_exp[3]) ||
			on_first_change[7])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port states[3] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", states_expected_prev);
		$display ("     Real value = %b", states_prev);
		nummismatches = nummismatches + 1;
		on_first_change[7] = 1'b0;
		last_states_exp[3] = states_expected_prev[3];
	end
	if (
		( states2_expected_prev[0] !== 1'bx ) && ( states2_prev[0] !== states2_expected_prev[0] )
		&& ((states2_expected_prev[0] !== last_states2_exp[0]) ||
			on_first_change[8])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port states2[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", states2_expected_prev);
		$display ("     Real value = %b", states2_prev);
		nummismatches = nummismatches + 1;
		on_first_change[8] = 1'b0;
		last_states2_exp[0] = states2_expected_prev[0];
	end
	if (
		( states2_expected_prev[1] !== 1'bx ) && ( states2_prev[1] !== states2_expected_prev[1] )
		&& ((states2_expected_prev[1] !== last_states2_exp[1]) ||
			on_first_change[8])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port states2[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", states2_expected_prev);
		$display ("     Real value = %b", states2_prev);
		nummismatches = nummismatches + 1;
		on_first_change[8] = 1'b0;
		last_states2_exp[1] = states2_expected_prev[1];
	end
	if (
		( states2_expected_prev[2] !== 1'bx ) && ( states2_prev[2] !== states2_expected_prev[2] )
		&& ((states2_expected_prev[2] !== last_states2_exp[2]) ||
			on_first_change[8])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port states2[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", states2_expected_prev);
		$display ("     Real value = %b", states2_prev);
		nummismatches = nummismatches + 1;
		on_first_change[8] = 1'b0;
		last_states2_exp[2] = states2_expected_prev[2];
	end
	if (
		( states2_expected_prev[3] !== 1'bx ) && ( states2_prev[3] !== states2_expected_prev[3] )
		&& ((states2_expected_prev[3] !== last_states2_exp[3]) ||
			on_first_change[8])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port states2[3] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", states2_expected_prev);
		$display ("     Real value = %b", states2_prev);
		nummismatches = nummismatches + 1;
		on_first_change[8] = 1'b0;
		last_states2_exp[3] = states2_expected_prev[3];
	end
	if (
		( stt_expected_prev[0] !== 1'bx ) && ( stt_prev[0] !== stt_expected_prev[0] )
		&& ((stt_expected_prev[0] !== last_stt_exp[0]) ||
			on_first_change[9])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt_expected_prev);
		$display ("     Real value = %b", stt_prev);
		nummismatches = nummismatches + 1;
		on_first_change[9] = 1'b0;
		last_stt_exp[0] = stt_expected_prev[0];
	end
	if (
		( stt_expected_prev[1] !== 1'bx ) && ( stt_prev[1] !== stt_expected_prev[1] )
		&& ((stt_expected_prev[1] !== last_stt_exp[1]) ||
			on_first_change[9])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt_expected_prev);
		$display ("     Real value = %b", stt_prev);
		nummismatches = nummismatches + 1;
		on_first_change[9] = 1'b0;
		last_stt_exp[1] = stt_expected_prev[1];
	end
	if (
		( stt_expected_prev[2] !== 1'bx ) && ( stt_prev[2] !== stt_expected_prev[2] )
		&& ((stt_expected_prev[2] !== last_stt_exp[2]) ||
			on_first_change[9])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt_expected_prev);
		$display ("     Real value = %b", stt_prev);
		nummismatches = nummismatches + 1;
		on_first_change[9] = 1'b0;
		last_stt_exp[2] = stt_expected_prev[2];
	end
	if (
		( stt_expected_prev[3] !== 1'bx ) && ( stt_prev[3] !== stt_expected_prev[3] )
		&& ((stt_expected_prev[3] !== last_stt_exp[3]) ||
			on_first_change[9])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt[3] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt_expected_prev);
		$display ("     Real value = %b", stt_prev);
		nummismatches = nummismatches + 1;
		on_first_change[9] = 1'b0;
		last_stt_exp[3] = stt_expected_prev[3];
	end
	if (
		( stt1_expected_prev[0] !== 1'bx ) && ( stt1_prev[0] !== stt1_expected_prev[0] )
		&& ((stt1_expected_prev[0] !== last_stt1_exp[0]) ||
			on_first_change[10])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt1[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt1_expected_prev);
		$display ("     Real value = %b", stt1_prev);
		nummismatches = nummismatches + 1;
		on_first_change[10] = 1'b0;
		last_stt1_exp[0] = stt1_expected_prev[0];
	end
	if (
		( stt1_expected_prev[1] !== 1'bx ) && ( stt1_prev[1] !== stt1_expected_prev[1] )
		&& ((stt1_expected_prev[1] !== last_stt1_exp[1]) ||
			on_first_change[10])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt1[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt1_expected_prev);
		$display ("     Real value = %b", stt1_prev);
		nummismatches = nummismatches + 1;
		on_first_change[10] = 1'b0;
		last_stt1_exp[1] = stt1_expected_prev[1];
	end
	if (
		( stt1_expected_prev[2] !== 1'bx ) && ( stt1_prev[2] !== stt1_expected_prev[2] )
		&& ((stt1_expected_prev[2] !== last_stt1_exp[2]) ||
			on_first_change[10])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt1[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt1_expected_prev);
		$display ("     Real value = %b", stt1_prev);
		nummismatches = nummismatches + 1;
		on_first_change[10] = 1'b0;
		last_stt1_exp[2] = stt1_expected_prev[2];
	end
	if (
		( stt1_expected_prev[3] !== 1'bx ) && ( stt1_prev[3] !== stt1_expected_prev[3] )
		&& ((stt1_expected_prev[3] !== last_stt1_exp[3]) ||
			on_first_change[10])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt1[3] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt1_expected_prev);
		$display ("     Real value = %b", stt1_prev);
		nummismatches = nummismatches + 1;
		on_first_change[10] = 1'b0;
		last_stt1_exp[3] = stt1_expected_prev[3];
	end
	if (
		( stt2_expected_prev[0] !== 1'bx ) && ( stt2_prev[0] !== stt2_expected_prev[0] )
		&& ((stt2_expected_prev[0] !== last_stt2_exp[0]) ||
			on_first_change[11])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt2[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt2_expected_prev);
		$display ("     Real value = %b", stt2_prev);
		nummismatches = nummismatches + 1;
		on_first_change[11] = 1'b0;
		last_stt2_exp[0] = stt2_expected_prev[0];
	end
	if (
		( stt2_expected_prev[1] !== 1'bx ) && ( stt2_prev[1] !== stt2_expected_prev[1] )
		&& ((stt2_expected_prev[1] !== last_stt2_exp[1]) ||
			on_first_change[11])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt2[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt2_expected_prev);
		$display ("     Real value = %b", stt2_prev);
		nummismatches = nummismatches + 1;
		on_first_change[11] = 1'b0;
		last_stt2_exp[1] = stt2_expected_prev[1];
	end
	if (
		( stt2_expected_prev[2] !== 1'bx ) && ( stt2_prev[2] !== stt2_expected_prev[2] )
		&& ((stt2_expected_prev[2] !== last_stt2_exp[2]) ||
			on_first_change[11])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt2[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt2_expected_prev);
		$display ("     Real value = %b", stt2_prev);
		nummismatches = nummismatches + 1;
		on_first_change[11] = 1'b0;
		last_stt2_exp[2] = stt2_expected_prev[2];
	end
	if (
		( stt2_expected_prev[3] !== 1'bx ) && ( stt2_prev[3] !== stt2_expected_prev[3] )
		&& ((stt2_expected_prev[3] !== last_stt2_exp[3]) ||
			on_first_change[11])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port stt2[3] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", stt2_expected_prev);
		$display ("     Real value = %b", stt2_prev);
		nummismatches = nummismatches + 1;
		on_first_change[11] = 1'b0;
		last_stt2_exp[3] = stt2_expected_prev[3];
	end
	if (
		( timer_reset_expected_prev !== 1'bx ) && ( timer_reset_prev !== timer_reset_expected_prev )
		&& ((timer_reset_expected_prev !== last_timer_reset_exp) ||
			on_first_change[12])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port timer_reset :: @time = %t",  $realtime);
		$display ("     Expected value = %b", timer_reset_expected_prev);
		$display ("     Real value = %b", timer_reset_prev);
		nummismatches = nummismatches + 1;
		on_first_change[12] = 1'b0;
		last_timer_reset_exp = timer_reset_expected_prev;
	end

	trigger <= ~trigger;
end
initial 

begin 
$timeformat(-12,3," ps",6);
#10000000;
if (nummismatches > 0)
	$display ("%d mismatched vectors : Simulation failed !",nummismatches);
else
	$display ("Simulation passed !");
$finish;
end 
endmodule

module lab3_vlg_vec_tst();
// constants                                           
// general purpose registers
reg GClock;
reg GReset_raw;
reg [3:0] msc;
reg [3:0] ssc;
reg sscs_raw;
// wires                                               
wire c_reset;
wire ccc;
wire main_t;
wire [2:0] mstl;
wire side_t;
wire [2:0] sstl;
wire [3:0] states;
wire [3:0] states2;
wire [3:0] stt;
wire [3:0] stt1;
wire [3:0] stt2;
wire timer_reset;

wire sampler;                             

// assign statements (if any)                          
lab3 i1 (
// port map - connection between master ports and signals/registers   
	.c_reset(c_reset),
	.ccc(ccc),
	.GClock(GClock),
	.GReset_raw(GReset_raw),
	.main_t(main_t),
	.msc(msc),
	.mstl(mstl),
	.side_t(side_t),
	.ssc(ssc),
	.sscs_raw(sscs_raw),
	.sstl(sstl),
	.states(states),
	.states2(states2),
	.stt(stt),
	.stt1(stt1),
	.stt2(stt2),
	.timer_reset(timer_reset)
);

// GClock
always
begin
	GClock = 1'b0;
	GClock = #20000 1'b1;
	#20000;
end 

// GReset_raw
initial
begin
	GReset_raw = 1'b1;
	GReset_raw = #100000 1'b0;
end 
// msc[ 3 ]
initial
begin
	msc[3] = 1'b0;
end 
// msc[ 2 ]
initial
begin
	msc[2] = 1'b1;
end 
// msc[ 1 ]
initial
begin
	msc[1] = 1'b1;
end 
// msc[ 0 ]
initial
begin
	msc[0] = 1'b0;
end 
// ssc[ 3 ]
initial
begin
	ssc[3] = 1'b1;
end 
// ssc[ 2 ]
initial
begin
	ssc[2] = 1'b0;
end 
// ssc[ 1 ]
initial
begin
	ssc[1] = 1'b1;
end 
// ssc[ 0 ]
initial
begin
	ssc[0] = 1'b1;
end 

// sscs_raw
always
begin
	sscs_raw = 1'b0;
	sscs_raw = #1500000 1'b1;
	#3500000;
end 

lab3_vlg_sample_tst tb_sample (
	.GClock(GClock),
	.GReset_raw(GReset_raw),
	.msc(msc),
	.ssc(ssc),
	.sscs_raw(sscs_raw),
	.sampler_tx(sampler)
);

lab3_vlg_check_tst tb_out(
	.c_reset(c_reset),
	.ccc(ccc),
	.main_t(main_t),
	.mstl(mstl),
	.side_t(side_t),
	.sstl(sstl),
	.states(states),
	.states2(states2),
	.stt(stt),
	.stt1(stt1),
	.stt2(stt2),
	.timer_reset(timer_reset),
	.sampler_rx(sampler)
);
endmodule

